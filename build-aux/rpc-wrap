#!/usr/bin/env python

import sys
import argparse
import inspect
import json
import operator

types = {
    type(None): {
        'decl': 'void',
        'sig': 'void',
        'js': 'Null'
    },
    int: {
        'decl': 'int',
        'sig': 'int',
        'js': 'Number'
    },
    float: {
        'decl': 'double',
        'sig': 'double',
        'js': 'Number'
    },
    bool: {
        'decl': 'bool',
        'sig': 'bool',
        'js': 'Boolean'
    },
    unicode: {
        'decl': 'std::string',
        'sig': 'std::string const&',
        'js': 'String'
    }
}

def typeconv(t, style):
    return types[type(t)][style]

class CodeWriter:
    def __init__(self, output, spaces=2, linesep='\n'):
        self.output = output
        self.spaces = spaces
        self.linesep = linesep
        self.tab = str()

    def wrapper(self, text):
        return reduce(operator.add, [self.tab, text, self.linesep])

    def out(self, text='', *args):
        self.output.write(self.wrapper(text.format(*args)))

    def indent(self):
        self.tab += ' ' * self.spaces

    def dedent(self):
        self.tab = self.tab[self.spaces:]

def main():
    """Generate a stub C++ header file from a JSON-RPC spec."""
    parser = argparse.ArgumentParser(description=inspect.getdoc(main))
    parser.add_argument('-s', '--spaces', type=int, default=2,
                        help='number of spaces per indent')
    parser.add_argument('-c', '--cname', type=str, default='spec',
                        help='C++ class name')
    parser.add_argument('-n', '--namespace', type=str, default=None,
                        help='C++ namespace')
    parser.add_argument('-o', '--output', type=argparse.FileType('w'),
                        default=sys.stdout, help='output C++ header')
    parser.add_argument('input', type=argparse.FileType('r'),
                        help='input JSON-RPC spec')
    args = parser.parse_args()

    spec = json.load(args.input)
    cw = CodeWriter(args.output, spaces=args.spaces)

    cw.out('#ifndef SPEC_INSTANCE_HH')
    cw.out('#define SPEC_INSTANCE_HH')
    cw.out()
    cw.out('/**')
    cw.out(' * C++ header generated by rpc-wrap.')
    cw.out(' */')
    cw.out()
    cw.out('#include <common/extension.h>')
    cw.out('#include <common/picojson.h>')
    cw.out('#include <dlog.h>')
    cw.out('#include <string>')
    cw.out('#include <functional>')
    cw.out()
    if args.namespace:
        cw.out('namespace {} {{', args.namespace)
        cw.indent()
    cw.out('using namespace std::placeholders;')
    cw.out()
    cw.out('class {} : public common::Instance {{', args.cname)
    cw.out('private:')
    cw.indent()
    cw.out('typedef std::function<picojson::value(picojson::object &)>')
    cw.out('        wrapper;')
    cw.out()
    cw.out('std::map<std::string, wrapper> fmap;')
    cw.out()
    cw.out('virtual void error(std::string const&) = 0;')
    for method in spec:
        name = method['name']
        params = ', '.join(typeconv(p, 'sig') for p in method['params'])
        returns = typeconv(method['returns'], 'decl')
        cw.out('virtual {} {}({}) = 0;', returns, name, params)
    cw.out()
    cw.out('void respond(picojson::value const& id,')
    cw.out('             picojson::value const& result) {{')
    cw.indent()
    cw.out('picojson::object response;')
    cw.out()
    cw.out('response["jsonrpc"] = picojson::value("2.0");')
    cw.out('response["result"] = result;')
    cw.out('response["id"] = id;')
    cw.out()
    cw.out('picojson::value json(response);')
    cw.out()
    cw.out('LOGD("responding with: %s", json.serialize().c_str());')
    cw.out()
    cw.out('PostMessage(json.serialize().c_str());')
    cw.dedent()
    cw.out('}}')
    for method in spec:
        name = method['name']
        params = method['params']
        returns = method['returns']
        sig = ', '.join(params)
        cw.out()
        cw.out('picojson::value {}_wrapper(picojson::object & p) {{',
               name)
        cw.indent()
        for k,v in params.items():
            cw.out('LOGD("calling method \'{}\'");', name)
            cw.out()
            cw.out('if (!p["{}"].is<{}>()) {{', k, typeconv(v, 'decl'))
            cw.indent()
            cw.out('error("JSON-RPC param \'{}\' not a {}");',
                   k, typeconv(v, 'js'))
            cw.dedent()
            cw.out('}}')
            cw.out()
        for k,v in params.items():
            cw.out('auto {0} = p["{0}"].get<{1}>();', k, typeconv(v, 'decl'))
        if type(returns) is type(None):
            cw.out('auto result = nullptr;')
        else:
            cw.out('auto result = {}({});', name, sig)
        cw.out()
        cw.out('return picojson::value(result);')
        cw.dedent()
        cw.out('}}')
    cw.dedent()
    cw.out()
    cw.out('public:')
    cw.indent()
    cw.out('{}() {{', args.cname)
    cw.indent()
    for method in spec:
        name = method['name']
        cw.out('fmap["{0}"] = std::bind(&{1}::{0}_wrapper, this, _1);',
               name, args.cname)
    cw.dedent()
    cw.out('}}')
    cw.out()
    cw.out('virtual ~{}() {{}}', args.cname)
    cw.out()
    cw.out('virtual void HandleMessage(char const* m) final {{')
    cw.indent()
    cw.out('picojson::value root;')
    cw.out()
    cw.out('auto err = picojson::parse(root, m);')
    cw.out()
    cw.out('if (!err.empty()) {{')
    cw.indent()
    cw.out('error(err);')
    cw.dedent()
    cw.out('}}')
    cw.out()
    cw.out('LOGD("received request: %s", root.serialize().c_str());')
    cw.out()
    cw.out('if (!root.is<picojson::object>()) {{')
    cw.indent()
    cw.out('error("JSON-RPC request is not a valid JSON object");')
    cw.dedent()
    cw.out('}}')
    cw.out()
    cw.out('LOGD("getting root object");')
    cw.out()
    cw.out('auto request = root.get<picojson::object>();')
    cw.out()
    cw.out('LOGD("checking method");')
    cw.out()
    cw.out('auto method = request["name"];')
    cw.out('if (!method.is<std::string>()) {{')
    cw.indent()
    cw.out('error("JSON-RPC request name is not a method");')
    cw.dedent()
    cw.out('}}')
    cw.out()
    cw.out('LOGD("checking params");')
    cw.out()
    cw.out('auto params = request["params"];')
    cw.out('if (!params.is<picojson::object>()) {{')
    cw.indent()
    cw.out('error("JSON-RPC request params is not an object");')
    cw.dedent()
    cw.out('}}')
    cw.out()
    cw.out('LOGD("checking id");')
    cw.out()
    cw.out('auto id = request["id"];')
    cw.out('if (!id.is<double>()) {{')
    cw.indent()
    cw.out('error("JSON-RPC request id is not a number");')
    cw.dedent()
    cw.out('}}')
    cw.out()
    cw.out('LOGD("dispatching to wrappers");')
    cw.out()
    cw.out('auto f = fmap[method.get<std::string>()];')
    cw.out('auto p = params.get<picojson::object>();')
    cw.out('auto result = f(p);')
    cw.out()
    cw.out('respond(id, result);')
    cw.dedent()
    cw.out('}}')
    cw.out()
    cw.out('virtual void HandleSyncMessage(char const* m) final {{')
    cw.indent()
    cw.out('SendSyncReply("{{}}");')
    cw.dedent()
    cw.out('}}')
    cw.dedent()
    cw.out('}};')
    if args.namespace:
        cw.dedent()
        cw.out('}}')
    cw.out()
    cw.out('#endif')
    cw.out()

if __name__ == '__main__':
    sys.exit(main())
